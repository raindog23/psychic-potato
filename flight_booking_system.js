// Generated by the AI based on the provided microservices architecture diagram and requirements. 
// Flight Booking System - Complete Implementation
// Based on the microservices architecture diagram

const express = require('express');
const Redis = require('redis');
const { Pool } = require('pg');
const axios = require('axios');
const cors = require('cors');

// Database Configuration
const dbConfig = {
  user: 'postgres',
  host: 'localhost',
  database: 'flight_booking',
  password: 'password',
  port: 5432,
};

const pool = new Pool(dbConfig);
const redis = Redis.createClient();

// API Gateway
class APIGateway {
  constructor() {
    this.app = express();
    this.app.use(cors());
    this.app.use(express.json());
    this.setupRoutes();
  }

  setupRoutes() {
    // Flight search routes
    this.app.get('/flights/:flightId', this.proxyRequest('search', 'GET'));
    this.app.get('/flights', this.proxyRequest('search', 'GET'));
    
    // Session management
    this.app.post('/sessions', this.proxyRequest('session', 'POST'));
    this.app.get('/sessions/:sessionId', this.proxyRequest('session', 'GET'));
    
    // Checkout and payments
    this.app.post('/checkout', this.proxyRequest('checkout', 'POST'));
    this.app.post('/payments', this.proxyRequest('checkout', 'POST'));
    
    // Inventory
    this.app.get('/inventory/:flightId', this.proxyRequest('inventory', 'GET'));
    this.app.post('/inventory/reserve', this.proxyRequest('inventory', 'POST'));
  }

  proxyRequest(service, method) {
    const serviceUrls = {
      search: 'http://localhost:3001',
      session: 'http://localhost:3002',
      checkout: 'http://localhost:3003',
      inventory: 'http://localhost:3004',
      discovery: 'http://localhost:3005'
    };

    return async (req, res) => {
      try {
        const response = await axios({
          method: method.toLowerCase(),
          url: `${serviceUrls[service]}${req.path}`,
          data: req.body,
          params: req.query
        });
        res.json(response.data);
      } catch (error) {
        res.status(500).json({ error: error.message });
      }
    };
  }

  start(port = 3000) {
    this.app.listen(port, () => {
      console.log(`API Gateway running on port ${port}`);
    });
  }
}

// Search Service (Elastic)
class SearchService {
  constructor() {
    this.app = express();
    this.app.use(express.json());
    this.setupRoutes();
  }

  setupRoutes() {
    this.app.get('/flights', this.searchFlights.bind(this));
    this.app.get('/flights/:flightId', this.getFlightById.bind(this));
  }

  async searchFlights(req, res) {
    const { originationId, destinationId, startDate, endDate, airlineId } = req.query;
    
    try {
      // Simulate Elasticsearch query
      const query = `
        SELECT f.*, a.name as airline_name 
        FROM flights f 
        JOIN airlines a ON f.airline_id = a.id
        WHERE ($1::text IS NULL OR f.origination_id = $1)
        AND ($2::text IS NULL OR f.destination_id = $2)
        AND ($3::date IS NULL OR f.departure_date >= $3)
        AND ($4::date IS NULL OR f.departure_date <= $4)
        AND ($5::text IS NULL OR f.airline_id = $5)
        ORDER BY f.departure_date, f.price
      `;
      
      const result = await pool.query(query, [originationId, destinationId, startDate, endDate, airlineId]);
      res.json(result.rows);
    } catch (error) {
      res.status(500).json({ error: error.message });
    }
  }

  async getFlightById(req, res) {
    try {
      const result = await pool.query('SELECT * FROM flights WHERE id = $1', [req.params.flightId]);
      if (result.rows.length === 0) {
        return res.status(404).json({ error: 'Flight not found' });
      }
      res.json(result.rows[0]);
    } catch (error) {
      res.status(500).json({ error: error.message });
    }
  }

  start(port = 3001) {
    this.app.listen(port, () => {
      console.log(`Search Service running on port ${port}`);
    });
  }
}

// Session Management Service (Pagination)
class SessionService {
  constructor() {
    this.app = express();
    this.app.use(express.json());
    this.setupRoutes();
  }

  setupRoutes() {
    this.app.post('/sessions', this.createSession.bind(this));
    this.app.get('/sessions/:sessionId', this.getSession.bind(this));
    this.app.put('/sessions/:sessionId', this.updateSession.bind(this));
    this.app.delete('/sessions/:sessionId', this.deleteSession.bind(this));
  }

  async createSession(req, res) {
    try {
      const sessionId = this.generateSessionId();
      const sessionData = {
        id: sessionId,
        searchCriteria: req.body.searchCriteria || {},
        selectedFlights: [],
        userInfo: req.body.userInfo || {},
        createdAt: new Date(),
        expiresAt: new Date(Date.now() + 30 * 60 * 1000) // 30 minutes
      };

      await redis.setEx(`session:${sessionId}`, 1800, JSON.stringify(sessionData));
      res.json({ sessionId, expiresAt: sessionData.expiresAt });
    } catch (error) {
      res.status(500).json({ error: error.message });
    }
  }

  async getSession(req, res) {
    try {
      const sessionData = await redis.get(`session:${req.params.sessionId}`);
      if (!sessionData) {
        return res.status(404).json({ error: 'Session not found or expired' });
      }
      res.json(JSON.parse(sessionData));
    } catch (error) {
      res.status(500).json({ error: error.message });
    }
  }

  async updateSession(req, res) {
    try {
      const sessionData = await redis.get(`session:${req.params.sessionId}`);
      if (!sessionData) {
        return res.status(404).json({ error: 'Session not found or expired' });
      }

      const session = JSON.parse(sessionData);
      Object.assign(session, req.body);
      session.updatedAt = new Date();

      await redis.setEx(`session:${req.params.sessionId}`, 1800, JSON.stringify(session));
      res.json(session);
    } catch (error) {
      res.status(500).json({ error: error.message });
    }
  }

  async deleteSession(req, res) {
    try {
      await redis.del(`session:${req.params.sessionId}`);
      res.json({ message: 'Session deleted' });
    } catch (error) {
      res.status(500).json({ error: error.message });
    }
  }

  generateSessionId() {
    return Math.random().toString(36).substring(2) + Date.now().toString(36);
  }

  start(port = 3002) {
    this.app.listen(port, () => {
      console.log(`Session Service running on port ${port}`);
    });
  }
}

// Checkout Service
class CheckoutService {
  constructor() {
    this.app = express();
    this.app.use(express.json());
    this.setupRoutes();
  }

  setupRoutes() {
    this.app.post('/checkout', this.processCheckout.bind(this));
    this.app.post('/payments', this.processPayment.bind(this));
    this.app.get('/checkout/:checkoutId', this.getCheckoutStatus.bind(this));
  }

  async processCheckout(req, res) {
    try {
      const { sessionId, flightIds, passengerInfo } = req.body;
      
      // Verify session
      const sessionData = await redis.get(`session:${sessionId}`);
      if (!sessionData) {
        return res.status(400).json({ error: 'Invalid or expired session' });
      }

      // Reserve seats
      const reservationResponse = await this.reserveSeats(flightIds);
      if (!reservationResponse.success) {
        return res.status(400).json({ error: 'Failed to reserve seats' });
      }

      // Create checkout record
      const checkoutId = this.generateCheckoutId();
      const checkout = {
        id: checkoutId,
        sessionId,
        flightIds,
        passengerInfo,
        reservationId: reservationResponse.reservationId,
        status: 'pending_payment',
        createdAt: new Date()
      };

      await pool.query(
        'INSERT INTO checkouts (id, session_id, flight_ids, passenger_info, reservation_id, status, created_at) VALUES ($1, $2, $3, $4, $5, $6, $7)',
        [checkoutId, sessionId, JSON.stringify(flightIds), JSON.stringify(passengerInfo), reservationResponse.reservationId, checkout.status, checkout.createdAt]
      );

      res.json({ checkoutId, status: checkout.status });
    } catch (error) {
      res.status(500).json({ error: error.message });
    }
  }

  async processPayment(req, res) {
    try {
      const { checkoutId, paymentMethod, amount } = req.body;

      // Get checkout details
      const checkoutResult = await pool.query('SELECT * FROM checkouts WHERE id = $1', [checkoutId]);
      if (checkoutResult.rows.length === 0) {
        return res.status(404).json({ error: 'Checkout not found' });
      }

      const checkout = checkoutResult.rows[0];

      // Process payment with Stripe (mock)
      const paymentResult = await this.processStripePayment(paymentMethod, amount);
      
      if (paymentResult.success) {
        // Confirm reservation
        await this.confirmReservation(checkout.reservation_id);
        
        // Update checkout status
        await pool.query('UPDATE checkouts SET status = $1, payment_id = $2 WHERE id = $3', 
          ['completed', paymentResult.paymentId, checkoutId]);

        res.json({ 
          success: true, 
          paymentId: paymentResult.paymentId,
          confirmationNumber: this.generateConfirmationNumber()
        });
      } else {
        res.status(400).json({ error: 'Payment failed' });
      }
    } catch (error) {
      res.status(500).json({ error: error.message });
    }
  }

  async getCheckoutStatus(req, res) {
    try {
      const result = await pool.query('SELECT * FROM checkouts WHERE id = $1', [req.params.checkoutId]);
      if (result.rows.length === 0) {
        return res.status(404).json({ error: 'Checkout not found' });
      }
      res.json(result.rows[0]);
    } catch (error) {
      res.status(500).json({ error: error.message });
    }
  }

  async reserveSeats(flightIds) {
    try {
      const response = await axios.post('http://localhost:3004/inventory/reserve', {
        flightIds,
        holdTime: 900 // 15 minutes
      });
      return response.data;
    } catch (error) {
      return { success: false, error: error.message };
    }
  }

  async confirmReservation(reservationId) {
    try {
      await axios.post(`http://localhost:3004/inventory/confirm/${reservationId}`);
      return true;
    } catch (error) {
      console.error('Failed to confirm reservation:', error.message);
      return false;
    }
  }

  async processStripePayment(paymentMethod, amount) {
    // Mock Stripe payment processing
    return new Promise((resolve) => {
      setTimeout(() => {
        const success = Math.random() > 0.1; // 90% success rate
        resolve({
          success,
          paymentId: success ? `pay_${Math.random().toString(36).substring(2)}` : null
        });
      }, 1000);
    });
  }

  generateCheckoutId() {
    return `checkout_${Math.random().toString(36).substring(2)}${Date.now()}`;
  }

  generateConfirmationNumber() {
    return Math.random().toString(36).substring(2, 8).toUpperCase();
  }

  start(port = 3003) {
    this.app.listen(port, () => {
      console.log(`Checkout Service running on port ${port}`);
    });
  }
}

// Inventory Service
class InventoryService {
  constructor() {
    this.app = express();
    this.app.use(express.json());
    this.setupRoutes();
  }

  setupRoutes() {
    this.app.get('/inventory/:flightId', this.getInventory.bind(this));
    this.app.post('/inventory/reserve', this.reserveSeats.bind(this));
    this.app.post('/inventory/confirm/:reservationId', this.confirmReservation.bind(this));
    this.app.post('/inventory/release/:reservationId', this.releaseReservation.bind(this));
  }

  async getInventory(req, res) {
    try {
      const result = await pool.query(
        'SELECT flight_id, total_seats, available_seats, reserved_seats FROM inventory WHERE flight_id = $1',
        [req.params.flightId]
      );
      
      if (result.rows.length === 0) {
        return res.status(404).json({ error: 'Flight inventory not found' });
      }

      res.json(result.rows[0]);
    } catch (error) {
      res.status(500).json({ error: error.message });
    }
  }

  async reserveSeats(req, res) {
    try {
      const { flightIds, seatsPerFlight = 1, holdTime = 900 } = req.body;
      const reservationId = this.generateReservationId();
      
      const client = await pool.connect();
      
      try {
        await client.query('BEGIN');
        
        for (const flightId of flightIds) {
          // Check availability
          const inventoryResult = await client.query(
            'SELECT available_seats FROM inventory WHERE flight_id = $1 FOR UPDATE',
            [flightId]
          );
          
          if (inventoryResult.rows.length === 0 || inventoryResult.rows[0].available_seats < seatsPerFlight) {
            throw new Error(`Insufficient seats available for flight ${flightId}`);
          }
          
          // Reserve seats
          await client.query(
            'UPDATE inventory SET available_seats = available_seats - $1, reserved_seats = reserved_seats + $1 WHERE flight_id = $2',
            [seatsPerFlight, flightId]
          );
          
          // Create reservation record
          await client.query(
            'INSERT INTO reservations (id, flight_id, seats_count, status, expires_at) VALUES ($1, $2, $3, $4, $5)',
            [reservationId, flightId, seatsPerFlight, 'held', new Date(Date.now() + holdTime * 1000)]
          );
        }
        
        await client.query('COMMIT');
        
        // Schedule release of reservation
        setTimeout(() => this.autoReleaseReservation(reservationId), holdTime * 1000);
        
        res.json({ 
          success: true, 
          reservationId,
          expiresAt: new Date(Date.now() + holdTime * 1000)
        });
        
      } catch (error) {
        await client.query('ROLLBACK');
        throw error;
      } finally {
        client.release();
      }
      
    } catch (error) {
      res.status(400).json({ success: false, error: error.message });
    }
  }

  async confirmReservation(req, res) {
    try {
      const { reservationId } = req.params;
      
      const result = await pool.query(
        'UPDATE reservations SET status = $1 WHERE id = $2 AND status = $3',
        ['confirmed', reservationId, 'held']
      );
      
      if (result.rowCount === 0) {
        return res.status(404).json({ error: 'Reservation not found or already processed' });
      }
      
      res.json({ success: true, message: 'Reservation confirmed' });
    } catch (error) {
      res.status(500).json({ error: error.message });
    }
  }

  async releaseReservation(req, res) {
    try {
      const { reservationId } = req.params;
      await this.performReservationRelease(reservationId);
      res.json({ success: true, message: 'Reservation released' });
    } catch (error) {
      res.status(500).json({ error: error.message });
    }
  }

  async performReservationRelease(reservationId) {
    const client = await pool.connect();
    
    try {
      await client.query('BEGIN');
      
      // Get reservation details
      const reservationResult = await client.query(
        'SELECT flight_id, seats_count FROM reservations WHERE id = $1 AND status = $2',
        [reservationId, 'held']
      );
      
      if (reservationResult.rows.length === 0) {
        return; // Already released or confirmed
      }
      
      for (const reservation of reservationResult.rows) {
        // Release seats back to inventory
        await client.query(
          'UPDATE inventory SET available_seats = available_seats + $1, reserved_seats = reserved_seats - $1 WHERE flight_id = $2',
          [reservation.seats_count, reservation.flight_id]
        );
      }
      
      // Update reservation status
      await client.query(
        'UPDATE reservations SET status = $1 WHERE id = $2',
        ['released', reservationId]
      );
      
      await client.query('COMMIT');
    } catch (error) {
      await client.query('ROLLBACK');
      throw error;
    } finally {
      client.release();
    }
  }

  async autoReleaseReservation(reservationId) {
    try {
      await this.performReservationRelease(reservationId);
      console.log(`Auto-released reservation: ${reservationId}`);
    } catch (error) {
      console.error(`Failed to auto-release reservation ${reservationId}:`, error.message);
    }
  }

  generateReservationId() {
    return `res_${Math.random().toString(36).substring(2)}${Date.now()}`;
  }

  start(port = 3004) {
    this.app.listen(port, () => {
      console.log(`Inventory Service running on port ${port}`);
    });
  }
}

// Discovery Service
class DiscoveryService {
  constructor() {
    this.app = express();
    this.app.use(express.json());
    this.setupRoutes();
  }

  setupRoutes() {
    this.app.get('/offers', this.getOffers.bind(this));
    this.app.get('/offers/:offerId', this.getOfferById.bind(this));
  }

  async getOffers(req, res) {
    try {
      const { destination, priceRange, dates } = req.query;
      
      const query = `
        SELECT o.*, f.origination_id, f.destination_id, f.departure_date, f.price
        FROM offers o
        JOIN flights f ON o.flight_id = f.id
        WHERE ($1::text IS NULL OR f.destination_id = $1)
        AND ($2::numeric IS NULL OR f.price <= $2)
        AND ($3::date IS NULL OR f.departure_date >= $3)
        AND o.active = true
        ORDER BY o.discount_percentage DESC, f.price ASC
      `;
      
      const result = await pool.query(query, [destination, priceRange, dates]);
      res.json(result.rows);
    } catch (error) {
      res.status(500).json({ error: error.message });
    }
  }

  async getOfferById(req, res) {
    try {
      const result = await pool.query('SELECT * FROM offers WHERE id = $1', [req.params.offerId]);
      if (result.rows.length === 0) {
        return res.status(404).json({ error: 'Offer not found' });
      }
      res.json(result.rows[0]);
    } catch (error) {
      res.status(500).json({ error: error.message });
    }
  }

  start(port = 3005) {
    this.app.listen(port, () => {
      console.log(`Discovery Service running on port ${port}`);
    });
  }
}

// Data Ingestion Service
class IngestionService {
  constructor() {
    this.app = express();
    this.app.use(express.json());
    this.setupRoutes();
  }

  setupRoutes() {
    this.app.post('/ingest/flights', this.ingestFlights.bind(this));
    this.app.post('/ingest/airlines', this.ingestAirlines.bind(this));
    this.app.post('/ingest/inventory', this.ingestInventory.bind(this));
  }

  async ingestFlights(req, res) {
    try {
      const flights = req.body.flights;
      const client = await pool.connect();
      
      try {
        await client.query('BEGIN');
        
        for (const flight of flights) {
          await client.query(
            `INSERT INTO flights (id, airline_id, origination_id, destination_id, departure_date, arrival_date, price, scheduled) 
             VALUES ($1, $2, $3, $4, $5, $6, $7, $8)
             ON CONFLICT (id) DO UPDATE SET
             price = EXCLUDED.price, scheduled = EXCLUDED.scheduled`,
            [flight.id, flight.airlineId, flight.originationId, flight.destinationId, 
             flight.departureDate, flight.arrivalDate, flight.price, flight.scheduled]
          );
        }
        
        await client.query('COMMIT');
        res.json({ success: true, processed: flights.length });
      } catch (error) {
        await client.query('ROLLBACK');
        throw error;
      } finally {
        client.release();
      }
    } catch (error) {
      res.status(500).json({ error: error.message });
    }
  }

  async ingestAirlines(req, res) {
    try {
      const airlines = req.body.airlines;
      
      for (const airline of airlines) {
        await pool.query(
          'INSERT INTO airlines (id, name, code) VALUES ($1, $2, $3) ON CONFLICT (id) DO UPDATE SET name = EXCLUDED.name, code = EXCLUDED.code',
          [airline.id, airline.name, airline.code]
        );
      }
      
      res.json({ success: true, processed: airlines.length });
    } catch (error) {
      res.status(500).json({ error: error.message });
    }
  }

  async ingestInventory(req, res) {
    try {
      const inventoryData = req.body.inventory;
      
      for (const inv of inventoryData) {
        await pool.query(
          `INSERT INTO inventory (flight_id, total_seats, available_seats, reserved_seats) 
           VALUES ($1, $2, $3, $4)
           ON CONFLICT (flight_id) DO UPDATE SET 
           total_seats = EXCLUDED.total_seats, 
           available_seats = EXCLUDED.available_seats`,
          [inv.flightId, inv.totalSeats, inv.availableSeats, inv.reservedSeats || 0]
        );
      }
      
      res.json({ success: true, processed: inventoryData.length });
    } catch (error) {
      res.status(500).json({ error: error.message });
    }
  }

  start(port = 3006) {
    this.app.listen(port, () => {
      console.log(`Ingestion Service running on port ${port}`);
    });
  }
}

// Database Schema Setup
const createTables = async () => {
  const tables = [
    `CREATE TABLE IF NOT EXISTS airlines (
      id VARCHAR(50) PRIMARY KEY,
      name VARCHAR(255) NOT NULL,
      code VARCHAR(10) NOT NULL
    )`,
    
    `CREATE TABLE IF NOT EXISTS flights (
      id VARCHAR(50) PRIMARY KEY,
      airline_id VARCHAR(50) REFERENCES airlines(id),
      origination_id VARCHAR(50) NOT NULL,
      destination_id VARCHAR(50) NOT NULL,
      departure_date TIMESTAMP NOT NULL,
      arrival_date TIMESTAMP NOT NULL,
      price DECIMAL(10,2) NOT NULL,
      scheduled BOOLEAN DEFAULT true,
      created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
    )`,
    
    `CREATE TABLE IF NOT EXISTS inventory (
      flight_id VARCHAR(50) PRIMARY KEY REFERENCES flights(id),
      total_seats INTEGER NOT NULL,
      available_seats INTEGER NOT NULL,
      reserved_seats INTEGER DEFAULT 0
    )`,
    
    `CREATE TABLE IF NOT EXISTS reservations (
      id VARCHAR(100) PRIMARY KEY,
      flight_id VARCHAR(50) REFERENCES flights(id),
      seats_count INTEGER NOT NULL,
      status VARCHAR(20) NOT NULL,
      expires_at TIMESTAMP,
      created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
    )`,
    
    `CREATE TABLE IF NOT EXISTS checkouts (
      id VARCHAR(100) PRIMARY KEY,
      session_id VARCHAR(100) NOT NULL,
      flight_ids TEXT NOT NULL,
      passenger_info TEXT NOT NULL,
      reservation_id VARCHAR(100) REFERENCES reservations(id),
      status VARCHAR(20) NOT NULL,
      payment_id VARCHAR(100),
      created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
    )`,
    
    `CREATE TABLE IF NOT EXISTS offers (
      id VARCHAR(50) PRIMARY KEY,
      flight_id VARCHAR(50) REFERENCES flights(id),
      discount_percentage DECIMAL(5,2) NOT NULL,
      description TEXT,
      active BOOLEAN DEFAULT true,
      valid_until TIMESTAMP,
      created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
    )`
  ];

  for (const table of tables) {
    await pool.query(table);
  }
  
  console.log('Database tables created successfully');
};

// Main Application Bootstrap
class FlightBookingSystem {
  constructor() {
    this.services = {};
  }

  async initialize() {
    try {
      await redis.connect();
      await createTables();
      
      // Initialize all services
      this.services.gateway = new APIGateway();
      this.services.search = new SearchService();
      this.services.session = new SessionService();
      this.services.checkout = new CheckoutService();
      this.services.inventory = new InventoryService();
      this.services.discovery = new DiscoveryService();
      this.services.ingestion = new IngestionService();
      
      console.log('All services initialized successfully');
    } catch (error) {
      console.error('Failed to initialize system:', error);
      process.exit(1);
    }
  }

  start() {
    // Start all services on different ports
    this.services.gateway.start(3000);
    this.services.search.start(3001);
    this.services.session.start(3002);
    this.services.checkout.start(3003);
    this.services.inventory.start(3004);
    this.services.discovery.start(3005);
    this.services.ingestion.start(3006);
    
    console.log('Flight Booking System started successfully!');
    console.log('API Gateway: http://localhost:3000');
  }
}

// Export for use
module.exports = {
  FlightBookingSystem,
  APIGateway,
  SearchService,
  SessionService,
  CheckoutService,
  InventoryService,
  DiscoveryService,
  IngestionService
};

// Start the system if this file is run directly
if (require.main === module) {
  const system = new FlightBookingSystem();
  system.initialize().then(() => {
    system.start();
  });
}